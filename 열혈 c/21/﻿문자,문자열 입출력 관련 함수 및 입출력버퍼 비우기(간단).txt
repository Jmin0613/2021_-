<문자 단위 입출력 함수>

문자 출력 함수 : putchar, fputc
공통점 : 단순 문자 전송 -> putchar와 fputc동일
차이점 : fputc는 문자를 전송할 스트림 지정 가능 -> 파일을 대상으로 데이터 전송 가능

문자 입력 함수 : getchar, fgetc
공통점 : 단순 문자 입력 -> getchar와 fgetc동일
차이점 : fgetc는 문자를 입력받을 스트림 지정 가능

EOF = end of file , 파일의 끝



<문자열 단위 입출력 함수>

문자열 출력 함수 : puts, fputs
puts는 별도개행 필요없음
fputs는 출력인자 결정가능

문자열 입력 함수 : gets, fgets
gets -> 단순하지만 마련해놓은 배열 길이 넘어가면 에러발생
fgets -> 길이를 입력받아서 그 길이 이상이면 자동으로 짤림 + 마지막 null문자 삽입으로 (사이즈-1) 입력됨



<표준 입출력과 버퍼>

표준입출력 함수를 통해 데이터 입출력 -> 데이터들은 운영체제가 제공하는 '메모리 버퍼'를 중간에 통과
(버퍼 : 임시 저장 공간)

why? 왜 버퍼를 통과해야할까?
answer -> 버퍼를 사용하는 것이 효율적이기 때문

눌린 문자를 바로바로 전송하는 것 보다는 엔터키를 누른 순간,
데이터를 한데 묶어서 전송하는 것이 효율적이고 빠름
ex) 연탄을 하나하나 손으로 옮기는 것보다 손수레에 가득 쌓고 옮기는 것이 효율적임



<출력 버퍼를 비우는 fflush 함수> -> 데이터 이동
출력버퍼가 비워짐 -> 출력버퍼에 저장된 데이터가 버퍼를 떠나 목적지로 "이동"
그런데 출력버퍼 비워지는 시점이 시스템이랑 버퍼성격 등 따라 다름
그래서 출력버퍼 비우는 함수를 알아둬야함

fflush(stdout); --> 표준 출력함수를 비워라
어떤 시스템의 어떤 표준 출력버퍼라고 해도, 버퍼 저장된 내용 비워지면, 데이터가 목적지로 이동 (강제 전송인가?)




<입력 버퍼 비우기> --> 삭제
입력버퍼의 비워짐(출력버퍼 비워지는거랑 다름) -> 데이터의 소멸
근데 왜 비워야함? 가끔 입력버퍼에 남아있는 불필요한 데이터가 있어서, 소멸해줘야하기 때문

void ClearLineFromReadBuffer(void){
	while(getchar()!='\n');
} --> 입력버퍼를 통째로 비우는게 아니라, \n이 읽힐때까지 입력버퍼에 저장된 문자들 지우는 함수


