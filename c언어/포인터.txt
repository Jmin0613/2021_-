포인터는 (type) *ptr =& (??)
ex) int *ptr=&a;
char *ptr=&a;

배열 포인터는 포인터이다
-> '배열'을 저장하는 '포인터'
-> 1차원에서의 배열 포인터은 중요x
-> 2차원배열에서의 배열 포인터 중요 ㅇㅇ

포인터 배열은 배열이다
-> '포인터'를 저장하는 '배열'
ex) int = arr[3];
arr[0]=(포인터저장)
arr[1]=(포인터저장)
arr[2]=(포인터저장)

배열 매개변수로 넘길때 어캐 넘기는지 중요
->1차원 배열 int example(int arr[]);
->2차원 배열 int example(int arr[][n]); n은 열의 숫자
배열은 저렇게 넘겨도 reference임 왜냐? arr[]자체가 포인터의 이름이고 포인터는 그 이름의 연속으로 메모리에 잇음 
arr[3]이면
주소값1번 arr[0] / 주소값2번 arr[1] / 주소값3번 arr[2] 이런식으로.
즉, 이름 그 자체(arr)가 포인터같은거임.(상수형 포인터)
arr는 포인터의 이름이면서 arr[0]의 값을 가짐 
그렇지만 arr(포인터의 이름)==arr[0] 인것은 아님. 구분해야함.

call-by-value,reference만 구분하면 됨

이후에 구조체 define 동적할당(배열의 크기 입력받아서 그 크기로 만들수잇음)

(배열의 크기 입력받아서 그 크기로 만들수잇음)
그동안 배열에 값 받을때는
int arr[100];
int n;
printf("입력받은 갯수 입력 : ");
scanf("%d", &n);
for(int i=0;i<n;i++){
	printf("%d 번째 요소 입력 : ", i+1);
	scanf("%d", arr[i]); //
}
로해서 배열을 넉넉히 잡아주고 입력받은 요소개수만큼 for을 통해 채워줬는데,
이러면 n=5인거 처럼 10보다 작은경우 메모리가 생성되고 채워지지않으니간 낭비됨
이걸위해서 동적할당(사용자가 스스로 메모리크기를 만들음)을 통해 만들 배열의 크기를 입력받고 그 크기로 만드는 것임
그러면 메모리 낭비 ㄴㄴ.